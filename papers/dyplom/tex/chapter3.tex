\chapter{Flutter}
\label{ch3}


\section{Все є віджитом або порівнняня віджетів з/без стану}
\label{section.3.1}
Однією з основних тем, яка супроводжує вас під час використання Flutter, є те, що на 80\% розробки це потужне використання віджетів.

Віджети Flutter побудовані з використанням сучасного фреймворку, який черпає натхнення у React \cite{flutter_widgets_intro}.
Основна ідея полягає в тому, що ви створюєте свій інтерфейс з віджетів.
Віджети описують, як повинен виглядати їхній вигляд, враховуючи їх поточну конфігурацію та стан.
Коли стан віджета змінюється, віджет відновлює свій опис, при цьому фреймфорк порівнює новий стан з попереднім,
визначає мінімальні зміни, та оновлює дерево візуалізації, таким чином, переходячи з одного стану в наступний.

Далі ми наводимо сирцевий код, що описує логіку ініціалізації додатку та визначає головний віджет додатку. \ref{lst:flutter_app_widget}

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_app_widget},caption=Flutter StatelessWidget]
// 1
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'data/breed_database.dart';
import 'home.dart';

Future<void> main() async {
  // 2
  WidgetsFlutterBinding.ensureInitialized();

  // 3
  final database = await BreedDatabase.create();

  // 4
  runApp(Provider<BreedDatabase>(
    create: (_) => database,
    child: MyApp(),
  ));
}

// 5
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 6
    return MaterialApp(
      // 7
      home: HomePage.create(context, title: 'Flutter List of Breeds'),
    );
  }
}
\end{lstlisting}

\begin{enumerate}
    \item Опис імпортовонах компенентів використовунах під час виконання додатку.
    \item Ініціалізуємо прив'язку Flutter фреймфорку.
    \item Створюємо підключення до бази даних.
    \item Викликаємо runApp і прив'язуємо посилання на базу даних до дерева віджетів.
    \item Опис кореневого віджету, котрий розширює віджет StatelessWidget(без стану).
    \item Створюємо спеціфічний віджет з пакету Google Material Design.
    \item Повертаємо віджет наступного рівня, котрий описує реалізацію головної сторінки.
\end{enumerate}

Як ми бачимо з наведеного сирцевого коду, по суті, розробка в Flutter подібна до гри з матрьошкою,
де ми вкладаємо один віджет в настуапний поступово додаючи складність до розвязання.

Треба звернути увагу, що головний віджет не має стану і тим самим визначає, що кореневий віджет буде не змінним
під час перерахування дерева після зміни стану в інших шарах додатку.

Тепер ознайомившись з прикладом віджету без стану, слід навести протилежність, а саме StateFullWidget(зі станом).
Ми зробимо це на прикладі списку котрий відображає додаток.

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_app_widget},caption=Flutter StatefulWidget]
// 1
class BreedList extends StatefulWidget {
  BreedList({Key? key, required this.viewModel}) : super(key: key);
  final BreedListViewModel viewModel;

  // 2
  @override
  _BreedListState createState() => _BreedListState();
}

class _BreedListState extends State<BreedList> {
  @override
  void initState() {
    super.initState();
    // 3
    widget.viewModel.loadBreedList();
  }

  // 4
  @override
  Widget build(BuildContext context) {
    return context
        .watch<BreedListState>()
        .when(loaded: showList, error: showError, loading: showLoading);
  }
}
\end{lstlisting}

\begin{enumerate}
    \item Визначаємо віджет та наслідуємо віджет StatefulWidget(зі станом).
    \item Реалізуємо контракт і створюємо об'єкт типу State<BreedList>.
    \item При ініціалізації віджету виконуємо код бізнес логіки. Тут завантажуємо список порід собак.
    \item Логіка відображування стану нашої "обіцянки". Можемо або отримати результат, або помилку, або стан "завантаження".
\end{enumerate}


\section{Система побудування з використанням Flutter CLI}
\label{section.3.2}
Flutter CLI - інструмент командного рядка котрий дозволяє створити, виконати, зібрати сирцевий код проектів фреймфорку Flutter.

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_cli_create},caption=Flutter Create Project]
flutter create my_app
cd my_app
flutter analyze
flutter test
flutter run lib/main.dart
\end{lstlisting}

Як видно в лістингу \ref{lst:flutter_cli_create} ми виконуємо команду, що створює, перевіряє, запускає тести та відтворює фактично код додатку.

Додатково набір інсрументів дозволяє завантажити, сконфігурувати та під'єднати транзитивні залежності проекту \ref{lst:flutter_pub}.
\begin{lstlisting}[style=light, language=Python,label={lst:flutter_pub},caption=Flutter Dependency Resolution]
flutter pub get
flutter pub outdated
flutter pub upgrade
\end{lstlisting}

Повний список залежностей можна знайти на офіційній веб сторінці \cite{flutter_cli}.


\section{Запити до мережі з http.dart}
\label{section.3.3}
Отримання даних з Інтернету необхідно для більшості програм. На щастя, Dart і Flutter надають інструменти, такі як httpпакет, для цього виду робіт.

В нашому додатку запит до інтернету описан в наступному описі сирцевого коду \ref{lst:flutter_networking}.

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_networking},caption=Flutter Networking]
import 'dart:convert';

import 'package:breed_flutter/domain/breed.dart';
import 'package:http/http.dart' as http;
import 'package:http/http.dart';

class BreedApi {
  // 1
  Future<List<Breed>> fetchBreeds() async {
    // 2
    final Uri url = Uri.parse('https://dog.ceo/api/breeds/list/all');
    // 3
    final Response response = await http.get(url);
    // 4
    final Map<String, dynamic> body = jsonDecode(response.body);
    // 5
    final Map<String, dynamic> message = body['message'];

    // 6
    if (response.statusCode == 200) {
      // 7
      return message.keys.map((breedName) {
        final List<dynamic> rawRaces = message[breedName];
        final List<String> races =
            rawRaces.map((race) => race.toString()).toList();
        return Breed.make(name: breedName, races: races);
      }).toList();
    } else {
      // 8
      throw Exception('Failed to load breed items');
    }
  }
}
\end{lstlisting}

\begin{enumerate}
    \item Запит виконується асинхронно.
    \item Створюємо універсальний ідентифікатор ресурсу до REST API, що поверне список пород собак.
    \item Очікуємо результат виконання запиту до інтернету.
    \item Декодуємо JSON результат, як асоціативний масив з динамічними типом(тобто не визначений).
    \item Отримаємо значення по ключу "message".
    \item Перевіряємо статус. 200 значить успіх.
    \item Адаптуємо результат в конкретний підтип визначений, як головний контракт додатку.
    \item Якщо невдалий запит повертаємо помилку виконання.
\end{enumerate}

Найголовнішим принципом, котрим ми опируємо в прикладі запиту до інтернету, це використання "обіцянок" на базі dart:async Future<T>.
Асинхронні операції дозволяють нашій програмі завершити роботу, чекаючи закінчення іншої операції.
Результат використання Future API або закінчиться в завершенному стані або незавершенному.

Коли ми вперше виконуємо асинхрону функцію, то отримаємо посилання на незавершену дію, з якої ми очікуємо результат або помилку.
Щоб уникнути розповсюдження помилки до верхнів шарів ми маємо використати try/catch синтаксис.

Як видно з нашого прикладу використання пакету http.dart в по'єднанні з dart:async дає зручне та швидке розв'язання проблеми створення та прослухання результатів з інтернету.
