\chapter{React Native}
\label{ch1}

\section{Декларативний}
\label{section.2.1}

React спрощує створення інтерактивних інтерфейсів.
Вам потрібно лише описати, як різні частини інтерфейсу виглядають у кожному стані вашого додатку і React ефективно оновить та відрендерить лише потрібні компоненти.
Декларативні інтерфейси роблять наш код більш передбачуваним і його набагато легше налагоджувати.

\section{Заснований на компонентах}
\label{section.2.2}
React Native заснований на основі інкапсульованих компонентів, які керують власним станом, і з них будують складні інтерфейси.
Оскільки логіка компонентів написана на JavaScript, замість шаблонів, ми з легкістю можемo передавати складні дані у додатку і зберігати стан окремо від DOM.

\section{JSX}
\label{section.2.3}
Розглянемо оголошення змінної:
\begin{lstlisting}[style=light, language=Python,label={lst:jsx_hello},caption=JSX Hello World]
const element = <h1>Hello, world!</h1>;
\end{lstlisting}

Цей дивний синтаксис тегів не є ні рядком, ні HTML.

Він має назву JSX, і це розширення синтаксису для JavaScript.
Його використовує React, щоб описати інтерфейс користувача.
JSX може нагадувати мову шаблонів, але з усіма перевагами JavaScript.

React використовує той факт, що логіка виводу пов’язана з іншою логікою інтерфейсу користувача: як обробляються події, як змінюється стан з часом і як дані готуються для рендерингу.

Замість того, щоб штучно відокремити технології, розмістивши розмітку і логіку в окремих файлах, React розділяє відповідальність між вільно зв’язаними одиницями, що містять обидві технології і називаються “компонентами”.
React не вимагає використання JSX, але більшість людей цінують його за візуальну допомогу при роботі з інтерфейсом користувача в коді JavaScript.
Він також дозволяє React показати зрозуміліші повідомлення про помилки та попередження.

\section{Система побудування Expo}
\label{section.2.4}
React Native пропонує два різних способи побудування проекту \textbf{«керований»} та \textbf{«простий»} робочими процесами.
\begin{itemize}
    \begin{item}
        За допомогою \textbf{керованого} робочого процесу ви пишете лише інструменти та служби JavaScript / TypeScript та Expo, які піклуються про все інше.
    \end{item}
    \begin{item}
        У \textbf{простому} робочому процесі ви маєте повний контроль над кожним аспектом власного проекту, а інструменти та послуги Expo трохи більш обмежені.
    \end{item}
\end{itemize}

В обох випадках використовується екосистема інструментів, що спрощують процес пободування проекту, ховаючи деталі та називається Expo.
Expo - платформа для універсальних додатків React, набір інструментів та служб, побудованих навколо React Native та власних платформ, які допомагають вам розробляти, будувати, розгортати та швидко переглядати iOS, Android та веб-додатки з тієї самої кодової бази JavaScript / TypeScript.\cite{expo_doc}

\section{Запити до мережі. Fetch API}
\label{section.2.5}
React Native надає API Fetch для ваших мережевих потреб.
API Fetch забезпечує інтерфейс для отримання ресурсів (у тому числі по всій мережі).
Буде здаватися звичним кожному, хто використовував XMLHttpRequest, але новий API забезпечує більш потужний та гнучкий набір функцій.
Fetch забезпечує загальне визначення Requestі Responseоб'єктів (та інших речей, пов'язаних із мережевими запитами).
Це дозволить їх використовувати там, де вони потрібні в майбутньому.

Fetch API залежить від Promise.
Promise або "обіцянка" - це проксі для значення, яке не обов'язково відомо при створенні об'єкту.\cite{promise_doc}
Інакше кажучи, це API обгортка, яка задає контракт згідно которого promise(обіцянка) може знаходитись в одному зі станів:
A Promiseзнаходиться в одному з таких станів:
\begin{itemize}
    \begin{item}
        \textbf{в очікуванні(peding)}: початковий стан, ні виконаний, ні відхилений.
    \end{item}
    \begin{item}
        \textbf{виконано(fulfilled)} : це означає, що операція була успішно завершена.
    \end{item}
    \begin{item}
        \textbf{відхилено(rejected)} : означає, що операція не вдалася.
    \end{item}
\end{itemize}

Прикладом коду, котрий виконує запит та отримує відповідь в форматі JSON.

\begin{lstlisting}[style=light, language=Python,label={lst:rn_network},caption=React Native Network Call]
const loadFromNetwork = () => {
  return fetch("https://dog.ceo/api/breeds/list/all")
    .then((response) => response.json())
    .then((json) => {
      return items;
    })
    .then((data) => setData(data))
    .catch((error) => console.error(error))
    .finally(() => setLoading(false));
};
\end{lstlisting}
