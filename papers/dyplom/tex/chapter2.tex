\chapter{Опис додатків з використанням кросс-платформених рішень}
\label{ch2}


\section{Структура проекту в React Native}
\label{sec:rn_structure_app}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_app_structure},caption=React Native App Layout]
├── App.js (1)
├── Readme.md
├── __tests__ (2)
│ └── App.js
├── android (3)
│ ├── app
│ ├── build
│ ├── build.gradle
│ ├── gradle
│ ├── gradle.properties
│ ├── gradlew
│ ├── gradlew.bat
│ ├── local.properties
│ └── settings.gradle
├── app.json (5)
├── babel.config.js (6)
├── index.js (7)
├── ios (4)
│ ├── BreedRN
│ ├── BreedRN.xcodeproj
│ ├── BreedRN.xcworkspace
│ ├── Podfile
│ ├── Podfile.lock
│ └── Pods
├── metro.config.js (8)
├── node_modules (11)
├── package-lock.json (10)
└── package.json (9)
\end{lstlisting}

\begin{enumerate}
    \item \textbf{App.js} сирцевий код нашого додатку
    \item \textbf{\_\_tests\_\_} сирцевий код тестів
    \item \textbf{android} сирцевий код платформеного коду Android
    \item \textbf{ios} сирцевий код платформеного коду iOS
    \item \textbf{app.json} конфігурує багато речей, від назви вашого додатка до піктограми до заставки, і навіть схеми глибоких зв’язків та ключів API для використання для деяких служб
    \item \textbf{babel.config.js} конфігурує Babel - це набір інструментів, який в основному використовується для перетворення коду ECMAScript 2015+ у зворотну сумісну версію JavaScript у поточних та старих браузерах або середовищах.
    \item \textbf{index.js} точка входу для React Native з цього файлу Javascript Engine вивантажує в пам'ять логіку додатку
    \item \textbf{metro.config.js} конфігурує Metro пакувальник JavaScript для платформ Android та iOS
    \item \textbf{package.json} конфігурує дерево залежностей або бібліотек, що використовує проект
    \item \textbf{package-lock.json} файл що описує повністю дерево залежностей, таким чином створює відтворюване середовище
    \item \textbf{node\_modules} репозиторій артефактів або сирцевого коду всіх Javascript пакетів, що використовує проект
\end{enumerate}


\section{Структура проекту в Flutter}
\label{sec:flutter_structure_app}

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_project_layout},caption=Flutter Project Layout]
├── README.md
├── android (1)
│ ├── app
│ ├── build.gradle
│ ├── gradle
│ ├── gradle.properties
│ ├── gradlew
│ ├── gradlew.bat
│ ├── local.properties
│ └── settings.gradle
├── build (2)
├── ios (3)
│ ├── Flutter
│ ├── Podfile
│ ├── Runner
│ ├── Runner.xcodeproj
│ └── Runner.xcworkspace
├── lib (4)
│ ├── breed_list.dart
│ ├── data
│ ├── domain
│ ├── home.dart
│ ├── main.dart
│ └── presentation
├── pubspec.lock (5)
├── pubspec.yaml (6)
├── test (7)
│ ├── breed_database_test.dart
│ ├── breed_list_view_model_test.dart
│ ├── breed_list_view_model_test.mocks.dart
│ └── network_test.dart
└── web (8)
    ├── favicon.png
    ├── icons
    ├── index.html
    └── manifest.json
\end{lstlisting}

\begin{enumerate}
    \item \textbf{android} сирцевий код платформеного коду Android.
    \item \textbf{build} папка з тимчасовими файлами згенерованими Flutter CLI під час побудування проекту.
    \item \textbf{ios} сирцевий код платформеного коду iOS.
    \item \textbf{lib} сирцевий код Flutter, котрий фактично є серцем репозиторія та описую логіку проекту.
    \item \textbf{pubspec.lock} файл що описує повністю дерево залежностей, таким чином створює відтворюване середовище.
    \item \textbf{pubspec.yaml} конфігурує дерево залежностей або бібліотек, що використовує проект.
    \item \textbf{test} сирцевий код тестів для платформи Flutter.
    \item \textbf{web} сирцевий код платформеного коду веб сторінки.
\end{enumerate}


\section{Структура проекту Kotlin Multi-Platform}
\label{sec:kmm_structure_app}

\begin{lstlisting}[style=light, language=Python,label={lst:kmm_project_layout},caption=KMM Project Layout]
├── app (1)
│ ├── build.gradle.kts
│ └── src
├── build.gradle.kts
├── buildSrc (2)
│ ├── build.gradle.kts
│ └── src
├── gradle
├── gradle.properties
├── gradlew
├── gradlew.bat
├── ios (3)
│ ├── Podfile
│ ├── Podfile.lock
│ ├── Pods
│ ├── bai_dialog_ios
│ ├── bai_dialog_ios.xcodeproj
│ ├── bai_dialog_ios.xcworkspace
│ ├── bai_dialog_iosTests
│ └── bai_dialog_iosUITests
├── local.properties
├── settings.gradle.kts
└── shared (4)
    ├── build.gradle.kts
    ├── consumer-rules.pro
    ├── proguard-rules.pro
    ├── shared.podspec
    └── src
        ├── androidMain (5)
        ├── androidTest (6)
        ├── commonMain (7)
        ├── commonTest (8)
        ├── iosMain (9)
        ├── iosTest (10)
        └── main (11)
\end{lstlisting}

\begin{enumerate}
    \item \textbf{app} сирцевий код UI імплементації для Android.
    \item \textbf{buildSrc} сирцевий код, що розширює систему розгортання Gradle.
    \item \textbf{ios} сирцевий код UI імплементації для iOS.
    \item \textbf{shared} папка в котрій зберігається загальний код.
    \item \textbf{androidMain} імплементація коду специфічного для Android платформи.
    \item \textbf{androidTest} імплементація тестів специфічних для Android платформи.
    \item \textbf{commonMain} сирцевий код спільної незалежної від платформи логіки.
    \item \textbf{commonTest} імплементація тестів для спільної незалежної від платформи логіки.
    \item \textbf{iosMain} імплементація коду специфічного для iOS платформи.
    \item \textbf{iosTest} імплементація тестів специфічних для iOS платформи.
    \item \textbf{main} репозиторій в якому зберігається код Android модуля, а саме статичні ресурси та AndroidManifest.
\end{enumerate}

\section{Архітектура додатків}
\label{sec:general_app_architecture}

Загальна задача всіх додатків для всіх платформ - це висвітлення списку порід собак з використанням ресурсу https://dog.ceo/api.
Отже серед поставлених задач було реалізація, як рівня коммунікації з мережею так і рівень взаємодії з закешованими
значеннями. Додатково було зроблено рішення підтримувати можливість реєстрації породи серед списку улюблених.

Поведінка всіх додатків наслідує послідовність дій описану на мал. \ref{fig:gen_app_flow}.

Загальна архітектура побудувана на базі подходу "чистої архітектури" (мал. \ref{fig:clean_architecture}).
Ідеологія архітектури, це організація коду по шарам абстракції \textbf{domain, presentation, data}.

\textbf{Рівень презентації} (або presentation) відповідає за відображення даних, фактично це дерево віджетів,
що ми відображуємо на сторінці.

\textbf{Рівень даних} (або data) відповідає за виклики до мережі, збереження даних в БД та робота з файловою системою.
Цей рівень знає де взяти дані.

\textbf{Рівень домену} (або domain) рівень бізнес логіки. В цьому рівні ми визначаємо контракт. Далі на базі контракту
ми будуємо рівень презентації.

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.25]{general_app_flow.png}
        \caption{Загальна схема послідовностей додатку}
        \label{fig:gen_app_flow}
    \end{center}
\end{figure}

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.4]{clean_architecture.png}
        \caption{Чиста архітектура (Clean Architecture)}
        \label{fig:clean_architecture}
    \end{center}
\end{figure}

В якості архітектурного рішення всі додатки імітують архітектуру MVVM(Model-View-View Model) (див. мал. \ref{fig:gen_app_architecture}).
\textbf{ViewModel} - це контроллер, що відповідає за комунікацію з Model рівнем та повертає структуру даних адаптовану під рівень презентації.
\textbf{Model} - це рівень, котрий описує формат рівню даних. На Model рівню ми описуємо контракт взаємодії з даними, як з
мережею так і з базою даних.
\textbf{View} - відповідає за відображення даних, по суті будучи пасивним спостерігачем даних з рівня ViewModel.

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.3]{app_layers.png}
        \caption{Загальна архітектура додатку}
        \label{fig:gen_app_architecture}
    \end{center}
\end{figure}

\section{Особливості архітектури додатку React Native}
\label{sec:kn_app_architecture}
В реалізації додатку React Native ми використали систему звротніх викликів або так званих "хуків".
Наприклад, \textbf{useState} - це Хук, що дозволяє додавати стан React до функціональних компонентів.

"useState" оголошує "змінну стану" та повертає пару значень: поточний стан та функцію, яка його оновлює.
Наша змінна називається, data ми можемо називати її як завгодно, наприклад banana \ref{lst:rn_state_hooks}.

Використовуючи useEffect хук, ми повідомляємо React, що наш компонент повинен виконати додаткову фунцію після рендерингу.
React запам'ятає передану нами функцію (яку ми будемо називати "ефектом") і викличе її пізніше після оновлення UI нашого додатку.

Ефект котрий ми створили буде виконаний при ініціалізації додатку. І як результат виконання ми отримаємо дані з локальної бази які ми і відобразимо (див. на \ref{fig:rn_realm})).

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.3]{app_widget.png}
        \caption{Взаємодія шарів абстракції в React Native}
        \label{fig:rn_realm}
    \end{center}
\end{figure}


\section{Особливості архітектури додатку Flutter}
\label{sec:flutter_network_app}

Архітектура додатку Flutter наслідує підхід "чистої архетиктури" (мал. \ref{fig:clean_architecture}).
На мал. \ref{fig:flutter_classes} відображено дерево взаємодії класів, де ми позначили залежність класу
від конкретного рівня абстракції на базі розшарування з (presentation, domain, data).

До \textbf{рівня презентації (presentation)} належать віджети Main, MyApp, HomePage, BreedList, BreedItem та
BreedListState, BreedListViewModel котрі відповідають за логіку комунікації з інформаційним та доменими рівнями.

До \textbf{рівня домену (domain)} належить Breed, котрий описує всю необхідну інформацію таку, як назва породи та чи
належить вона до списку улюблених.

До \textbf{рівня даних (data)} належить BreedApi та BreedDatabase. На цьому рівні описана взаємодія з БД та мережею.

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.4]{flutter_classes.png}
        \caption{Діаграма класів Flutter}
        \label{fig:flutter_classes}
    \end{center}
\end{figure}


\section{Особливості архітектури додатку Kotlin Multiplatform}
\label{sec:kmm_architecture}

Проект, незалежно від того, працює він в Android або iOS, використовує базові компоненти презентації
Activity для Android та ViewController для iOS платформ.

Компонент презентації створють BreedModel, конфігурують зворотні виклики(callbacks) та стартують BreedModel.
BreedModel є загальним кодом MultiPlatform, тому ми вже в загальному коді.
BreedModel реалізовує кросс-платформений код та посилається на бібліотеку Multiplatform-Settings,
та два допоміжні класи: DogApiImpl (який реалізує KtorApi) і DatabaseHelper.

DatabseHelper та DogApiImpl використовують бібліотеки Multiplatform для отримання даних і повернення їх до BreedModel.
Зауважимо, що BreedModel посилається на інтерфейс KtorApi. Це дає можливість протестувати модель за допомогою Mock(заглушки) Api.

BreedModel підписується на потік змін з бази даних. Таким чином, будь-які зміни в базі даних будуть викликати
зворотній виклик та відновлювати рівень презентації.
Описана модель повертає список собачих порід та відображає на рівні презентації.
Модель отримує інформацію з мережі, а потім зберігає дані в базі даних.

Отримаємо наступний приклад описаний на мал. \ref{fig:kmm_architecture}.

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.4]{kmm_architecture.png}
        \caption{Взаємодія шарів абстракції в KMM}
        \label{fig:kmm_architecture}
    \end{center}
\end{figure}

Останій пазл нашої конфігурації полягає в використанні мультиплатформенної бібліотеки для зберігання налаштувань (див. мал. \ref{fig:kmm_app_flow}).
В нашому випадку ми використовуємо це рішення для того, щоби зберігати час останьої обнови, а саме коли було в останнє запит до серверу.
Коли до BreedModel виконує запит на отримання списку пород з мережі, наша модель спочатку перевіряє, чи виконано це запит протягом минулої години.
Якщо відповідь негативна, то модель приймає вирішення оновити список порід.

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.3]{kmm_app_flow.png}
        \caption{Послідовність дій для перевірки закешовоного стану в KMM}
        \label{fig:kmm_app_flow}
    \end{center}
\end{figure}
