\appendix
\renewcommand{\appendixname}{Додаток}


\chapter{Сирцевий код}
\label{cha:appendix1}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_network},caption=React Native Network Call]
const loadFromNetwork = () => {
  return fetch("https://dog.ceo/api/breeds/list/all")
    .then((response) => response.json())
    .then((json) => {
      return items;
    })
    .then((data) => setData(data))
    .catch((error) => console.error(error))
    .finally(() => setLoading(false));
};
\end{lstlisting}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_realm},caption=React Native Realm]
# We define the schema of the table
const BreedSchema = {
  name: "Breed",
  primaryKey: "id",
  properties: {
    id: "string",
    name: "string",
    isFavorite: { type: "bool", default: false },
  },
};

# We do list all schemas available and configure conflict resolution strategy
const config = {
  deleteRealmIfMigrationNeeded: true,
  schema: [BreedSchema],
};

# Finally we do consume the values from the database
const loadFromDatabase = () => {
  return Realm.open(config).then((realm) => {
    const breeds = realm
      .objects("Breed")
      .filtered(`TRUEPREDICATE SORT(name ASC) DISTINCT(name)`);
    # For each item we need detach it from the Realm to avoid accidental mutations
    const items = breeds.map(copyObjects);
    realm.close();
    return items;
  });
};
\end{lstlisting}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_state_hooks},caption=React Native Hooks]
export default function App() {
  # Declaring state of array of items
  const [data, setData] = useState([]);
  # Mark the code as one that defines effect. In this case we read from DB.
  useEffect(() => {
    // 3
    loadFromDatabase().then((data) => setData(data));
  });

  # Return the list of items as widget that transforms data as <Item> widget
  return <FlatList
    data={data}
    renderItem={({ item }) => {
      return <Item item={item} />;
    }}
    keyExtractor={(item) => item.id}
  />
}
\end{lstlisting}
