\appendix
\renewcommand{\appendixname}{Додаток}


\chapter{Сирцевий код}
\label{cha:appendix1}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_network},caption=React Native Network Call]
const loadFromNetwork = () => {
  return fetch("https://dog.ceo/api/breeds/list/all")
    .then((response) => response.json())
    .then((json) => {
      return items;
    })
    .then((data) => setData(data))
    .catch((error) => console.error(error))
    .finally(() => setLoading(false));
};
\end{lstlisting}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_realm},caption=React Native Realm]
# We define the schema of the table
const BreedSchema = {
  name: "Breed",
  primaryKey: "id",
  properties: {
    id: "string",
    name: "string",
    isFavorite: { type: "bool", default: false },
  },
};

# We do list all schemas available and configure conflict resolution strategy
const config = {
  deleteRealmIfMigrationNeeded: true,
  schema: [BreedSchema],
};

# Finally we do consume the values from the database
const loadFromDatabase = () => {
  return Realm.open(config).then((realm) => {
    const breeds = realm
      .objects("Breed")
      .filtered(`TRUEPREDICATE SORT(name ASC) DISTINCT(name)`);
    # For each item we need detach it from the Realm to avoid accidental mutations
    const items = breeds.map(copyObjects);
    realm.close();
    return items;
  });
};
\end{lstlisting}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_state_hooks},caption=React Native Hooks]
export default function App() {
  # Declaring state of array of items
  const [data, setData] = useState([]);
  # Mark the code as one that defines effect. In this case we read from DB.
  useEffect(() => {
    // 3
    loadFromDatabase().then((data) => setData(data));
  });

  # Return the list of items as widget that transforms data as <Item> widget
  return <FlatList
    data={data}
    renderItem={({ item }) => {
      return <Item item={item} />;
    }}
    keyExtractor={(item) => item.id}
  />
}
\end{lstlisting}


\begin{lstlisting}[style=light, language=Python,label={lst:flutter_app_widget},caption=Flutter StatelessWidget]
# All imported from Dart pubsub packages installed locally
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'data/breed_database.dart';
import 'home.dart';

Future<void> main() async {
  # Make sure widgets intitialised, so that we can avoid tree state inconsistencies
  WidgetsFlutterBinding.ensureInitialized();

  # We do create an instance that connects to the local SQLite database
  final database = await BreedDatabase.create();

  # runApp kicks off the widget creation
  # we do pass a Provider that delegates database instance
  # to any leaf of widget tree interested in making calls
  runApp(Provider<BreedDatabase>(
    create: (_) => database,
    child: MyApp(),
  ));
}

# It is a root widget instantiated
# marked as one without a state management
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    # We do use the Material Design widgets
    return MaterialApp(
      # The home widget represented with HomePage
      home: HomePage.create(context, title: 'Flutter List of Breeds'),
    );
  }
}
\end{lstlisting}

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_app_widget},caption=Flutter StatefulWidget]
# We are declaring widget
# and inherit widge that will hold a state object
class BreedList extends StatefulWidget {
  BreedList({Key? key, required this.viewModel}) : super(key: key);
  final BreedListViewModel viewModel;

  @override
  _BreedListState createState() => _BreedListState();
}

# State object holds infor about state
# and uses widge to access dependencies
class _BreedListState extends State<BreedList> {
  @override
  void initState() {
    super.initState();
    # As soon as widget instantiated we do consume list of items
    widget.viewModel.loadBreedList();
  }

  # Lastly we use context to observe chages of the state
  @override
  Widget build(BuildContext context) {
    return context
        .watch<BreedListState>()
        .when(loaded: showList, error: showError, loading: showLoading);
  }
}
\end{lstlisting}
