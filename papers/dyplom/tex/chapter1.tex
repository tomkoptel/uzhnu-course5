\renewcommand{\proofname}{Доведення}
\renewcommand{\chaptername}{РОЗДІЛ}


\chapter{Огляд теоретичної частини розробки з крос-платформеними фреймворками}
\label{ch1}


\section{Тренди серед мобільних фреймворків}
\label{sec:trends}

\subsection{Розробка крос-платформних мобільних додатків}
\label{subsec:cross_platform_dev}
Завдяки міжплатформенній розробці підприємства та організації змогли охопити ширшу аудиторію, ефективніше та з меншими витратами.
React Native був представлений Facebook у 2015 році.
React Native - це фреймворк для мобільних додатків з відкритим кодом, який використовує React із власними можливостями платформи для розробки додатків для Android, iOS, Web та UWP.

Список компаній, що використовують React Native в своїх мобільних додатках: Facebook, Instagram, Tesla, Uber Eats, Discord, Wix, Walmart.

Компетентний розробник React Native повинен знати JavaScript + React Native SDK, Kotlin + Android SDK, Swift + iOS SDK, що в 3 рази більше знань у порівнянні зі звичайними розробниками мобільних пристроїв.
Звідси відсутність хороших розробників та підвищення ціни розробки майже у 3 рази (3 платформи).
Якщо ви вирішите використовувати React Native треба розважити це рішення, оскільки для переходу на інші кроссплатформенні фреймворки потребує повну переробку коду додатку.

Flutter був представлений Google у травні 2017 року. Але випуск стабільної версії відбувся у грудні 2018 року.
Flutter також має відкритий вихідний код і використовується для розробки програм для Android, iOS, Linux, Mac, Windows, Google Fuchsia та веб.

Деякі програми створені за допомогою Flutter це - Google Ads, Alibaba.com, Realtor.com.

Оскільки Flutter та React-Native стали найгарячішою темою останніх днів
та конкурентними дебатами серед спільноти розробників, багато розробників залижаються у невизначеності.

Flutter екосистема ще не настільки зріла, як в випадку React Native, але швидко розвивається.
Власні бібліотеки та код можна інтегрувати з програмами Flutter, тому, так само як і в React Native,
тут потрібні знання SDK нативних iOS та Android.
Знову та сама проблема з трьома мовами, що вимагає від розробників одночасного володіння Flutter SDK, iOS SDK та Android SDK.
Оскільки Flutter використовує Dart, а фреймворк написаний майже з нуля,
розробникам буде важко перенести проекти Flutter на інші крос-платформні фреймворки або власні програми.
Як і в випадку React Native потрібно буде переписати все з нуля.

Цільова аудиторія Kotlin Multiplatform - це нативні розробники мобільних платформ, які вже використовують Kotlin на Android та Swift на iOS.
Іншими словами, це розробники, які глибоко розуміють рідні мобільні SDK, яким потрібно вивчити лише одну нову мову (Swift або Kotlin).
Головний недолік Kotlin Mutlitplatform - це те, що фреймфорк досі в Alpha версії. На період 5 травня 2021 це версія 0.2.4 (див. \cite{kmm_plugin_releases}).

\begin{center}
    \begin{longtable}{|p{0.23\textwidth}|p{0.22\textwidth}|p{0.22\textwidth}|p{0.23\textwidth}|}
        \caption{Порівняння Фреймворків}
        \label{tab:framwework_comparison}
        \\ \hline
        & React Native                               & Flutter                               & Kotlin Multiplatform                              \\
        \hline \endfirsthead
        \subcaption{Продовження таблиці~\ref{tab:framwework_comparison}}
        \\ \hline \endhead
        \hline \subcaption{Продовження на слід. стор.}
        \endfoot
        \hline \endlastfoot
        Вперше з’явився       & 2015                                & 2017                                & 2018                               \\
        \hline
        Розроблено                   & Facebook                         & Google                               & JetBrains                            \\
        \hline
        Відкрите джерело         & Так                                & Так                                & Так                               \\
        \hline
        Мова             & Javascript                           & Dart                           & Kotlin                               \\
        \hline
        Нативні Модулі & Так                      & Так                      & Так                             \\
        \hline
        Сумісність   & Обмежена & Обмежена & Так \\
        \hline
        Інші мови для вивчення                    & Kotlin, Swift                & Kotlin, Swift                     & Swift             \\
        \hline
        Клікість Розробників      & 42\%\cite{worldwide_sf_work_hours}                     & 39\%\cite{worldwide_sf_work_hours}                & 2\%\cite{worldwide_sf_work_hours}  \\
        \hline
        IDE      & Немає офіційної IDE                     & Android Studio                & Android Studio, XCode  \\
        \hline
        Цільова аудиторія      & Веб-розробники                     & Розробники флаттера                & Розробники під мобільні пристрої  \\
    \end{longtable}
\end{center}

\subsection{Тренди}
\label{subsec:mobile_trends}

\begin{figure}
    \includegraphics[width=\textwidth]{flutter_react_trend_5_years.png}
    \caption{Відповідно до Google Trends за 5 років}
    \label{fig:flutter_react_trend_5_years}
\end{figure}

На Google Trends за останні п’ять років Flutter випередив React Native (див. рис.~\ref{fig:flutter_react_trend_5_years}).
Але це не визначає, що Flutter - кращиий за React Native.

Порівнюючи тренди між Kotlin, Flutter та Reactive Native за 12 місяців спостерігається більша зацікавленість Flutter.
Де Kotlin (див. рис.~\ref{fig:flutter_react_trend_12_months_1}) демонструє меньшу зацікавленість.
\begin{figure}
    \includegraphics[width=\textwidth]{flutter_react_trend_12_months_1.png}
    \caption{Інтерес за часом Google Trends за 12 місяців \cite{google_trends}}
    \label{fig:flutter_react_trend_12_months_1}
\end{figure}

Оцінюючи мапу світу (див. рис.~\ref{fig:flutter_react_trend_12_months_2}) можна зробити висновок,
що Flutter є лідером по зацікавленості серед регіонів, коли React Native уступає всім трьом.

\begin{figure}
    \includegraphics[width=\textwidth]{flutter_react_trend_12_months_2.png}
    \caption{Розподілення по регіонам \cite{google_trends}}
    \label{fig:flutter_react_trend_12_months_2}
\end{figure}

Якщо враховувати, тенденцій розвитку міжплатформенних технологій мобільних додатків React Native та Flutter досить схожі за популярністю.
Обидві технології посідають дуже високе місце на GitHub.
В лютому 2021 Flutter має 112 тис. зірок \cite{flutter_gihtub} та React Native 93.2 тис. \cite{rn_gihtub}.

На мал. \ref{fig:stackoverflow_survey_2020} видно, що інтерес до Flutter значно зріс у 2021 році і швидко зростає.

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.65]{stackoverflow_survey_2020.png}
    \end{center}
    \caption{Основна популярність за результатами опитування, яке охопило 40 000 відповідей. \cite{stackoverflow_survey_2020}}
    \label{fig:stackoverflow_survey_2020}
\end{figure}

\subsection{Плюси та мінуси кросс-платформеної розробки}
\label{sec:plus_minus_cross_platform}

Перш ніж як порівняти конкретні мінуси платформ треба розглянути загальні характреристики, що платформи поділяють
між собою (див. табл. \ref{tab:plus_minus_cross_platform}).

\begin{longtable}[c]{|l|l|}
    \caption{Плюси кросс-платформеної розробки.}
    \label{tab:plus_minus_cross_platform} \\
    \hline
    Переваги &
    Недоліки \\ \hline
    \endhead
%
    \begin{tabular}[c]{@{}l@{}}
        Спільна бізнес логіка:\\ - виклики до мережі;\\ - взаємодія з базою даних;\\ - трансформація даних;
    \end{tabular} &
    \begin{tabular}[c]{@{}l@{}}
        Потреба в знанні нативних\\ iOS/Android SDK.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Спільні тести для спільного\\ сирцевого коду.
    \end{tabular} &
    \begin{tabular}[c]{@{}l@{}}
        Зміна контексту між мовами\\ програмування:\\ - RN: Swift, Objective-C, Kotlin, \\ Javascript.\\ - Flutter: Dart, Swift, Kotlin.\\ - KMM: Swift, Kotlin.
    \end{tabular} \\ \hline
    Відкритий сирцевий код. &
    \begin{tabular}[c]{@{}l@{}}
        Більш складне розгортаннє на\\ стороні CI/CD серверів.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Менші затрати на розробку\\ спільних частин.
    \end{tabular} &
    Складніше відлагодження дефектів. \\ \hline
    &
    \begin{tabular}[c]{@{}l@{}}
        Розробка та підтримка мостів\\ для сумісності.
    \end{tabular} \\ \hline
\end{longtable}

Flutter та React Native вирішують проблему крос-платформеної розробки за рахунок API абстракції, що дозволяє розробляти
спільний рівень репрезентації. Такий підхід нав'язує спільні характеристики між платформами (див. табл. \ref{tab:rn_flutter_commons}).

\begin{longtable}[c]{|l|l|}
    \caption{Плюси Flutter та React Native}
    \label{tab:rn_flutter_commons} \\
    \hline
    Переваги                     & Недоліки                     \\ \hline
    \endhead
%
    Спільна логіка репрезентації & Більше використання RAM, CPU \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Спільна база компонентів між \\ веб та мобільною розробками
    \end{tabular} &
    \begin{tabular}[c]{@{}l@{}}
        Повільніший перший запуск\\ cold start.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Швидкі ітерації під час розробки\\ за рахунок hot swap технології.
    \end{tabular}                &                              \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Менші затрати на розробку\\ спільних частин.
    \end{tabular}                &                              \\ \hline
\end{longtable}

\subsection{Особливості платформи Flutter}
\label{sec:flutter_specifics}

Flutter підтримує як мобільні платформи Android, так і iOS, і,
оскільки він відображає все самостійно, він дозволяє запускати все з однієї кодової бази.

У Flutter користувальницький інтерфейс побудований за допомогою віджетів,
невеликих будівельних блоків інтерфейсу, зібраних за допомогою техніки, що називається композиція.
Весь процес схожий на використання компонентів React.
Існує два набори віджетів, що доступні: Material Design, який сумісний з дизайнерськими вказівками Google,
та Cupertino, який сумісний з Apple's вказівками для iOS.

Flutter управляє кожним пікселем екрану, звідси впевненість, що віджети додатку будуть виглядати
однаково на всіх мобільних пристроях. Це дозволяє нам створювати дивовижні на вигляд
користувальницькі інтерфейси, які виглядають абсолютно однаково як на Android, так і на iOS.

Функція hot reload (гарячого перезавантаження) забезпечує можливість внесення змін в режимі реального часу.
Ця функція мінімізує час очікування на результат змін під час розробки.
Hot reload досягається за рахунок можливостей мови програмування Dart.
Dart може виконувати код, як в режимі інтерпретації, так і компіляції.
Саме режим інтерпретації дозволяє реалізувати можливість hot reload.
В свою чергу, компіляція дозволяє згенерувати оптимізований байт код,
що значно покращує продуктивність застосунку.

Узагальнення плюсів та мінусів описано в табл. \ref{tab:flutter_specifics}.

\begin{longtable}[c]{|l|l|}
    \caption{Переваги та недоліки Flutter.}
    \label{tab:flutter_specifics} \\
    \hline
    Переваги &
    Недоліки \\ \hline
    \endhead
%
    Спільна кодова база. &
    \begin{tabular}[c]{@{}l@{}}
        Відсутність підтримки смарт\\ годиників та ТВ платформ.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        ого
        Красиві інтерфейси \\ в найкоротші терміни.
    \end{tabular} &
    \begin{tabular}[c]{@{}l@{}}
        Затримки в підтримуванні \\ найновших можливостей \\ рідних платформ
    \end{tabular} \\ \hline
    Pixel perfect. &
    \begin{tabular}[c]{@{}l@{}}
        Більше використання\\ RAM та CPU.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Hot reload\\ (гаряче перезавантаження).
    \end{tabular} &
    Більший розмір додатку. \\ \hline
    Відкритий сирцевий код &
    \\ \hline
\end{longtable}

\subsection{Особливості платформи React Native}
\label{subsec:rn_pros_cons}

До переваг користування платформою React Native можна віднести:
можливість використання досвіду веб розробника,
спільна кодова база,
контроль стану.

React Native - це зрілий фреймворк зі стабільним API, який підтримує Facebook.

Розробники додатків на React Native для веб можуть перевикористати набутий досвід, а тому легше буде перейти на нову платформу.

Так само, як Flutter, він дозволяє швидко розроблювати додатки iOS, Android та Web зі спільною кодовою базою.

React Native допомогає з управлінням стану при зміні конфігурацій часу виконання.

До недоліків користування платформою React Native можна віднести:
відсутність підтримки смарт годиників та ТВ платформ,
затримки в підтримуванні найновших можливостей рідних платформ,
замітне сповільнення при завантаженні JS середовища.
Середовище виконання Javascript однопотокова, тому ціна спілкування з нативною середою
виконання більш висока.

Навігація не є плавною і пов'язано з необхідністю запуску додаткового середовища виконання для Javascript коду.

React Native - це не найкращий вибір для програм, які потребують складну анімацію (на приклад ігри).

\begin{longtable}[c]{|l|l|}
    \caption{Переваги та недоліки React Native.}
    \label{tab:rn_specifics} \\
    \hline
    Переваги &
    Недоліки \\ \hline
    \endhead
%
    Спільна кодова база. &
    \begin{tabular}[c]{@{}l@{}}
        Відсутність підтримки смарт\\ годиників та ТВ платформ.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Красиві інтерфейси\\ в найкоротші терміни.
    \end{tabular} &
    \begin{tabular}[c]{@{}l@{}}
        Затримки в підтримуванні \\ найновших можливостей \\ рідних платформ
    \end{tabular} \\ \hline
    Підтримка веб. &
    \begin{tabular}[c]{@{}l@{}}
        Більше використання\\ RAM та CPU.
    \end{tabular} \\ \hline
    \begin{tabular}[c]{@{}l@{}}
        Hot reload\\ (гаряче перезавантаження).
    \end{tabular} &
    Більший розмір додатку. \\ \hline
    Відкритий сирцевий код. &
    \\ \hline
\end{longtable}

\subsection{Мови програмування}
\label{subsec:languages}

Flutter використовує мову, що називається Dart.
Це мова, яка має синтаксис, подібний до Java та Javascript.

Простим прикладом коду в Dart буде:
\begin{lstlisting}[style=light, language=Python,label={lst:vectorimg},caption=Dart Hello World]
void main () { 
  print ("Hello World!"); 
}
\end{lstlisting}

React Native використовує Javascript.
React Native побудований поверх React, який побудований на Javascript.
Тому, якщо вам доведеться вивчити React Native, вам знадобляться попередні знання Javascript.

Javascript існує довкола спільноти розробників програмного забезпечення дуже давно, і існує безліч ресурсів, на яких можна навчитися javascript.
Простим прикладом коду в javascript буде:

\begin{lstlisting}[style=light, language=Python,label={lst:vectorimg},caption=Dart Hello World]
  alert("Hello World!");
\end{lstlisting}

\subsection{Спільнота розробників}
\label{subsec:communities}

Google витратив багато на розробку Dart, і спільнота продовжує зростати.
Flutter має спільноти на StackOverflow, Slack та багатьох інших платформах.

React Native має більшу спільноту розробників, ніж Flutter.
Спільнота Javascript є навіть більшою, ніж спільнота React Native, оскільки вона існує з березня 2015, тому допомогу можна знайти майже скрізь в Інтернеті.
Це, безумовно, пояснює, чому React Native має вищий рівень прийняття в порівнянні з Flutter.
Крім того, підтримка React, React Native та Javascript в Інтернеті є більш доступною.
Є мільйони рядків коду, які є у вільному доступі в Інтернеті, і їх можна використовувати у своїх проектах.
На сторінці спільноти React Native на їх офіційному веб-сайті вказані інші платформи, що вміщують їхні спільноти, такі як StackOverflow та Medium.

Найкраще у Dart - це те, що він постачається з повним набором віджетів інтерфейсу.

В React Native, набір віджетів інтерфейсу мінімальний, і тому розробникам програмного забезпечення та програмістам доводиться звертатися до сторонніх бібліотек для віджетів інтерфейсу або створювати власні рішення.

\subsection{Порівняння доступних вакансій на ринку Британії}
\label{subsec:market_comparisson}
Розглянемо статистичні дані, щодо популярності платформ на ринку праці.
В якості ринку праці була вибрана Велика Британія, оскільки вона має досить розвиненний ринок IT.
За основну метрику розглянемо кількість вакансій доступних за остані 6 місяців.

Кількість вакансій доступних для React Native розробників 877, де 908 було за той самий період в 2020 і 750 за 2019 \cite{react_native_jobs}.
Вакансій на Flutter меньше всього 113 за 2021, 49 за 2020 та 12 за 2019 \cite{flutter_jobs}.
Враховуючи ці дані можна зробити висновок, що React Native показує більшу зацікавленість на ринку праці.
Однак, в захист Flutter можна додати, що за остатній рік в рейтингу вакансій Flutter піднявся на 309 пунктів \cite{flutter_jobs}, коли React Native на 165 \cite{react_native_jobs}.

Нажаль схожої статистики по Kotlin Mutliplatform не вдалося точно виявити.
Загальна тенденція вакансій по Kotlin, як мови програмування показує нам 917 за 2021, 1196 за 2020 та 644 за 2019 роки \cite{kotlin_jobs}.

Цікавим спостереженням є медіана зарплат де Kotlin розробнику пропонують £70,000\cite{kotlin_jobs}, React Native £60,000\cite{react_native_jobs} та Flutter £52,500\cite{flutter_jobs}.
Таку тенденцію можно пояснити широкопрофільним застосуванням Kotlin, як в розробці Backend так і Frontend клієнтів.


\section{Порівняння продуктивності Fluter, React Native та Native}
\label{sec:benchmarking}

В даному розділі аналіз побудован на основі результатів виконання тестів продуктивності виконаних на пристроях Xiaomi Redmi Note 5 та iPhone 6s.
Проекти були створенні на наступних версіях програмного забезпечення: React Native 0.62.0, Flutter >=2.7.0 <3.0.0, Android 29 та iOS 9.0.

Самі додатки та результати були розроблені в компанії inVerita \cite{inVerita}.

Перший випадок тестує продуктивність додатків, що показують списки обсягом в 1000 елементів.
Результат виконання тесту на Android див. рис. \ref{fig:android_benchmark_list}, де
для iOS див. рис. \ref{fig:ios_benchmark_list}.
Для обох платформ частота кадрів тримається в значеннях 60.
На платформі Android найгірші результати продемонструвала платформа React Native, яка використовує найбільше ресурсів.
На платформі iOS React Native також продемонструвала найгірші результати, окрім використання ресурсів GPU.

В другому і третьому випадках були протестовані анімації (див. рис.
\ref{fig:android_benchmark_animations}, рис. \ref{fig:ios_benchmark_animations},
рис. \ref{fig:android_benchmark_animations2}, рис. \ref{fig:ios_benchmark_animations2}).

При виконані більш простих анімацій на платформі Android найкращий результат використання ресурсів CPU та RAM було
досягненно для платформи Flutter, хоча остання продемонструвала найгірше значення частоти кадрів в 9 одиниць.
При тестуванні анімацій на iOS платформі найкращий результат був досягнут на нативній базі коду з 30 одиницями.
Flutter так само, як і випадку з Android платформою продемонстрував найнижче значення частоти кадрів всього 8 одиниць.

В останьому тесті найкращі результати тестів продуктивності спостерігаються для нативних платформ де як і FPS був близький до 60 кадрів в секунду,
так і використання RAM, GPU та CPU були найнижчі. Як і в першому так і в третьому тестах React Native продемонструвала
себе, як платформа з найвищими показниками використання ресурсів пристрою.

Тест рендерінгу списків для Android платформи (див. рис. \ref{fig:android_benchmark_list}) показали приблизно однаковий FPS.
Android Native використовує вдвічі менше пам'яті порівняно з Flutter і React Native.
React Native вимагає найбільш значної експлуатації процесора.
Причиною є використання JSBridge між JS та власним кодом, що спонукає до втрати ресурсів на серіалізацію та десеріалізацію даних.
Що стосується експлуатації акумулятора, Android Native має найкращий результат.
React-native відстає як від Android, так і від Flutter.
Запуск безперервної анімації споживає більше енергії акумулятора на React Native.

\begin{figure}[h]
    \includegraphics[width=\textwidth]{android_benchmark_list.png}
    \caption{Android тестовий аналіз продуктивності рендерінгу списків}
    \label{fig:android_benchmark_list}
\end{figure}
\FloatBarrier

Результати тестів рендерінгу списків для iOS платформи (див. рис. \ref{fig:ios_benchmark_list}) для React Native гірші, ніж результати Flutter та Swift.
Причиною є неможливість використовувати компіляцію IoT на iOS.
Пам'ять Flutter майже відповідає споживанню пам'яті на iOS Native.
У цьому тесті React Native значно відстає від Flutter та нативної платформ.
Flutter активно використовує процесор, коли iOS Native активно використовує графічний процесор.

Результати тестів рендерінгу анімацій для Android платформи (див. рис. \ref{fig:android_benchmark_animations})
продемонструвало схожі результати для React Native та нативної платформи.
Flutter в цьому тесті видав всього лише 9 кадрів в секунду.
Android вимагає найменшого обсягу пам'яті (205 Мб), React Native потребує 280 Мб, а Flutter - 266 Мб.
Холодний запуск програми з Flutter є лідером (2 секунди).
Для Android Native та React Native це займає близько 4 секунд.

\FloatBarrier
\begin{figure}[h]
    \includegraphics[width=\textwidth]{ios_benchmark_list.png}
    \caption{iOS тестовий аналіз продуктивності рендерінгу списків}
    \label{fig:ios_benchmark_list}
\end{figure}

\begin{figure}[h]
    \includegraphics[width=\textwidth]{android_benchmark_animations.png}
    \caption{Android тестовий аналіз продуктивності анімацій}
    \label{fig:android_benchmark_animations}
\end{figure}

Результати тестів рендерінгу анімацій для iOS платформи (див. рис. \ref{fig:ios_benchmark_animations})
та React Native у цьому тесті майже однакові.
iOS Native вимагає найменшого обсягу пам'яті (48 Мб). React Native потребує 135 Мб, а Flutter 117 Мб.
Холодний запуск програми з Flutter є лідером (2 секунди).
Для iOS та React Native це займає близько 10 секунд.

\FloatBarrier
\begin{figure}[h]
    \includegraphics[width=\textwidth]{ios_benchmark_animations.png}
    \caption{iOS тестовий аналіз продуктивності анімацій}
    \label{fig:ios_benchmark_animations}
\end{figure}
\FloatBarrier

Результати тестів рендерінгу складних анімацій для Android платформи (див. рис. \ref{fig:android_benchmark_animations2})
продемонстрували високу продуктивність та найбільш ефективне споживання пам'яті.
Flutter продемонстрував достатню продуктивності, щоб комфортно працювати, але вдвічі більше витрат пам'яті порівняно з рідною.
React Native — показав низьку продуктивність у цьому випадку.

\begin{figure}[h]
    \includegraphics[width=\textwidth]{android_benchmark_animations2.png}
    \caption{Android тестовий аналіз продуктивності важких анімацій}
    \label{fig:android_benchmark_animations2}
\end{figure}

Результати тестів рендерінгу складних анімацій для iOS платформи (див. рис. \ref{fig:ios_benchmark_animations2})
продемонстрували високу продуктивність на нативній платформі.
React Native використовував переважно процесор для рендерингу, тоді як Flutter використовував графічний процесор.
React Native використовував трохи більше пам'яті.

\begin{figure}[h]
    \includegraphics[width=\textwidth]{ios_benchmark_animations2.png}
    \caption{iOS тестовий аналіз продуктивності важких анімацій}
    \label{fig:ios_benchmark_animations2}
\end{figure}


\section{Фреймворк React Native}
\label{sec:rn}

\subsection{Декларативність та React Native}
\label{subsec:rn_declarative}

React фреймвок - є \textbf{декларативним} та спрощує створення інтерактивних інтерфейсів.
Достатньо описати, як різні частини інтерфейсу виглядають у кожному стані в додатку і React ефективно оновить та відрендерить лише потрібні компоненти.
Декларативні інтерфейси роблять код більш передбачуваним і його набагато легше налагоджувати.

React Native \textbf{заснований на інкапсульованих компонентах}, які керують власним станом, і з них будують складні інтерфейси.
Оскільки логіка компонентів написана на JavaScript, замість шаблонів,
тепер з легкістю можна передавати складні дані у додатку і зберігати стан окремо від DOM.

Розглянемо оголошення змінної:
\begin{lstlisting}[style=light, language=Python,label={lst:jsx_hello},caption=JSX Hello World]
const element = <h1>Hello, world!</h1>;
\end{lstlisting}

Цей дивний синтаксис тегів не є ні рядком, ні HTML.

Він має назву \textbf{JSX}, і це розширення синтаксису для JavaScript.
Його використовує React, щоб описати інтерфейс користувача.
JSX може нагадувати мову шаблонів, але з усіма перевагами JavaScript.

React використовує той факт, що логіка виводу пов’язана з іншою логікою інтерфейсу користувача: як обробляються події, як змінюється стан з часом і як дані готуються для рендерингу.

Замість того, щоб штучно відокремити технології, розмістивши розмітку і логіку в окремих файлах, React розділяє відповідальність між вільно зв’язаними одиницями, що містять обидві технології і називаються "компонентами".
React не вимагає використання JSX, але більшість людей цінують його за візуальну допомогу при роботі з інтерфейсом користувача в коді JavaScript.
Він також дозволяє React показати зрозуміліші повідомлення про помилки та попередження.

\subsection{React та система побудування Expo}
\label{subsec:rn_expo}
React Native пропонує два різних способи побудування проекту \textbf{«керований»} та \textbf{«простий»} робочиі процеси.

За допомогою \textbf{керованого} робочого процесу пишется лише JavaScript код без необхідності підтримки нативної бази коду.
Expo - платформа для універсальних додатків React, набір інструментів та служб, побудованих навколо
React Native та нативних платформ, які допомагають розробляти, будувати, розгортати та швидко переглядати iOS,
Android та веб-додатки з тієї самої кодової бази JavaScript / TypeScript.\cite{expo_doc}

У \textbf{простому} робочому процесі є повний контроль над сирцевим кодом, як нативних та Javascript платформ.
В цьому випадку потрібне знанная, як платформи React Native так і вміння розробля ти з наитивними SDK.
З простим робочим процесом ми маємо повний контроль над процесом побудови додатків, що і є головним різницею в порівнянні з Expo.

\subsection{React та запити до мережі з Fetch API}
\label{subsec:rn_fetch_api}

Fetch API - інтерфейс для створенняв запитів до інтернету.
Fetch API дозволяє створювати Request та Response об'єкти.

Fetch API побудован на основі Promise API.
Promise або "обіцянка" - це проксі для значення, яке не обов'язково відомо при створенні об'єкту.\cite{promise_doc}
Інакше кажучи, це API обгортка, яка задає контракт згідно которого promise(обіцянка) може знаходитись в одному зі станів:

Promise знаходиться в одному з таких станів:
\begin{itemize}
    \begin{item}
        \textbf{в очікуванні(peding)}: початковий стан, не виконаний, не відхилений.
    \end{item}
    \begin{item}
        \textbf{виконано(fulfilled)} : це означає, що операція була успішно завершена.
    \end{item}
    \begin{item}
        \textbf{відхилено(rejected)} : означає, що операція не вдалася.
    \end{item}
\end{itemize}

Прикладом коду, котрий виконує запит та отримує відповідь в форматі JSON можна знайти в додатку \ref{lst:rn_network}.

\subsection{Realm React Native}
\label{subsec:rn_realm}
В випадку вибору бази даних треба розглянути наступні фактори:
\begin{itemize}
    \begin{item}
        \textbf{Технологія:} з відкритим кодом чи власністю?
    \end{item}
    \begin{item}
        \textbf{Архітектура:} SQL або NoSQL?s
    \end{item}
    \begin{item}
        \textbf{Масштабованість:} чи ви будете самостійно розміщувати або скористаєтесь масштабованою послугою?
    \end{item}
\end{itemize}

Ринок надає можливість використання таких рішень (див. \ref{tab:rn_db_comparison}).

\begin{longtable}[c]{|l|l|l|}
    \caption{Порівняння Баз Даниx React Native}
    \label{tab:rn_db_comparison} \\
    \hline
    & Сирцевий код  & Тип реаліаційної БД \\ \hline
    \endhead
%
    Back4app        & Відкритий     & SQL, NoSQL          \\ \hline
    Cloud Firestore & Пропрієтарний & NoSQL               \\ \hline
    DigitalOcean    & Відкритий     & SQL                 \\ \hline
    AWS RDS         & Відкритий     & SQL                 \\ \hline
    Realm           & Відкритий     & NoSQL               \\ \hline
\end{longtable}

Під час роботи над тестовим продуктом було зроблене рішення використати Realm.
Рішення базувалося скоріше на потребах швидкій та простій реалізації.
Як наведено в додатку \ref{lst:rn_realm} конфігурація є проста.

Спочатку ми описуємо схему бази даних (див. \ref{fig:rn_realm}). В даному випадку одна таблиця.
Створюємо об'єкт конфігурації, котрий буде використаний, щоби відкрити підключення до бази даних.
Передавши конфігурацію ми отримаємо відкрите підключення до бази даних та робимо запит до таблиці.
Запит повертає нам результат зі збереженими даним з котрих ми робимо копію кожного об\'єкту.
Особливість Realm об\'єктів полягає в тому, що вони є вікном до курсору в таблиці.
Щоби уникнути випадкових змін в таблиці ми спеціально робимо копію, яка є "чистим" об\'єктом від\'єднаним від БД.

\FloatBarrier
\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.4]{rn_realm.png}
    \end{center}
    \caption{Взаємодія React Native додатку з БД}
    \label{fig:rn_realm}
\end{figure}
\FloatBarrier

\subsection{React Native та управління станом}
\label{subsec:rn_state_management}

Використання React Hooks дозволяє швидко і в простий спосіб сконфігурувати стан нашого компоненту.
Нажаль для складних компонентів з великою кількістю взаємодій
з користувачем використання React Hooks призведе до високої зв'язаності коду,
складного до зрозуміння сирцевого коду і нестабільного рішення з великою кількістю помилок.
Для рішення цієї проблеми можна застосувати архітектуру Redux.

Redux - це передбачуваний контейнер стану для Javascript додатків (див. на \ref{fig:rn_redux})).
Redux допомагає писати програми, які поводяться послідовно та працюють у різних середовищах (клієнтських, серверних та власних). \cite{redux_home_page}
Централізація стану та логіки вашого додатка забезпечує потужні можливості, такі як скасування / повтор,
однорідність стану. \cite{redux_home_page}

\FloatBarrier
\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.23]{redux.png}
    \end{center}
    \caption{Схема Redux}
    \label{fig:rn_redux}
\end{figure}
\FloatBarrier

\subsection{Тестування в React Native}
\label{subsec:rn_testing}
У міру розширення вашої кодової бази невеликі помилки та крайні випадки, на які ви не очікуєте, можуть перетворюватися на більші збої.
Помилки призводять до поганого досвіду для користувачів і, зрештою, до втрат бізнесу.
Одним із способів поліпшити якість сирцевого коду є написання тестів.

Одним з найкращих способів виправити помилку в коді є написання тесту, який виявляє її.
Потім, коли ви виправляєте помилку і повторно запускаєте тест, якщо він проходить, це означає, що помилка виправлена,
і ніколи повторно не буде впроваджена в сирцевий код проекту.

Тести також можуть служити документацією для нових людей, які приєднуються до вашої команди.
Людям, які ніколи раніше не бачили кодової бази, аналіз тестів може допомогти зрозуміти, як працює існуючий код.
Нарешті, але не менш важливим є те, що більш автоматизоване тестування означає менше часу, проведеного на
ручне відлагоджування якості.

За замовчуванням React Native постачається з тестовою структурою Jest. \cite{jest_home_page}

\begin{lstlisting}[style=light, language=Python,label={lst:rn_jest_test},caption=Jest Unit Test]
  it('given 2 +2 returns 4', () => {
    expect(2 + 2).toBe('red');
  });
\end{lstlisting}

Jest дозволяє групувати тести з уживанням функцій "describe"(опис).
Підтримує хуки для ініціалізації стану "beforeEach"(перед кожним) та "beforeAll"(після всіх).

Unit test(єдносткові тести) допомагають протестувати тільки бізнес логіку.
Для тестування UI компонентів застосовується компонентне тестування.
Навіть якщо логіка вашого додатка має високий рівень охоплення тестуванням і є правильною,
без тестування компонентів ви все одно можете доставити непрацюючий інтерфейс для своїх користувачів.

Під час тестування компонентів React можна перевірити дві речі:

\begin{itemize}
    \begin{item}
        \textbf{Взаємодію:} для забезпечення належної поведінки компонента під час взаємодії з ним користувачем (наприклад, коли користувач натискає кнопку)
    \end{item}
    \begin{item}
        \textbf{Рендеринг:} щоб переконатися, що вихідний вигляд компонента, який використовує React, правильний (наприклад, зовнішній вигляд кнопки та розміщення її в інтерфейсі)
    \end{item}
\end{itemize}

Однак треба мати на увазі, що тестування компонентів - це лише тести JavaScript, що виконуються у середовищі Node.js.
Вони не беруть до уваги iOS, Android або інший код платформи, який підтримує компоненти React Native.
Звідси випливає, що вони не можуть надати нам 100\% впевненості, що все працює.
Якщо в коді платформи iOS або Android є помилка тести її не знайдуть.

Останій клас тестів - це ті, що дозволяють протестувати в наскрізний спосіб наш додаток (далі E2E - End to End).
Це робиться шляхом запуску тестів на фінальній зборці додатку виконаному в середовищі Android або iOS.
У тестах E2E ви більше не думаєте про компоненти React, React Native API, Redux чи будь-яку бізнес-логіку.

Тести E2E дають нам максимально можливу впевненість у тому, що додаток працює.
Однак в випадку E2E тестів треба враховувати наступні компроміси.

\begin{itemize}
    \item їх написання займає більше часу порівняно з іншими типами тестів
    \item вони працюють повільніше
    \item вони більш нестабільні "flakky" ("flakky"  - це тест, який випадково проходить і не проходить без будь-яких змін в коді)
\end{itemize}

Доступно кілька інструментів тестування E2E.
\begin{itemize}
    \item у спільноті React Native Detox є популярним фреймворком, оскільки він спеціально підходить для додатків React Native.\cite{detox_home_page}
    \item ще однією популярною бібліотекою для iOS та Android додатків є Appium.\cite{appium_home_page}
\end{itemize}


\section{Фреймворк Flutter}
\label{sec:flutter}

\subsection{Flutter порівнняня віджетів з/без стану}
\label{subsec:flutter_widgets_theory}
Однією з основних тем, яка супроводжує вас під час використання Flutter, є те, що на 80\% розробки це потужне використання віджетів.

Віджети Flutter побудовані з використанням сучасного фреймворку, який був натхненний React\'ом \cite{flutter_widgets_intro}.
Основна ідея полягає в тому, що ви створюєте свій інтерфейс з віджетів.
Віджети описують, як повинен виглядати їхній вигляд, враховуючи їх поточну конфігурацію та стан.
Коли стан віджета змінюється, віджет відновлює свій опис, при цьому фреймфорк порівнює новий стан з попереднім,
визначає мінімальні зміни, та оновлює дерево візуалізації, таким чином, переходячи з одного стану в наступний.

Головна структура будь-якого Flutter додатку будується на основі віджетів.
Згідно зі специфікацією Dart першочергове, що ми робимо - це імпортоуємо компененти за допомогою конструкції \textbf{import}.
Наступними кроками буде ініціалізація в \textbf{main()} функції дерева віджеті
за допомогою \textbf{WidgetsFlutterBinding.ensureInitialized()} та
виклик функції \textbf{runApp()}, що прив'язує визначене нами дерево до віджетів.

Далі я навожу сирцевий код, що описує логіку ініціалізації додатку та визначає головний віджет додатку.
З наведеного сирцевого коду (див. \ref{lst:flutter_app_widget}) можна зробити висновок,
що розробка в Flutter подібна до гри з матрьошкою, де ми вкладаємо один віджет в наступний поступово
ускладнюючи презентацію.

Треба звернути увагу (див. \ref{lst:flutter_app_widget}),
що головний віджет не має стану і тим самим визначає, що кореневий віджет буде не змінним
під час перерахування дерева після зміни стану в інших шарах додатку.

Тепер ознайомившись з прикладом віджету без стану, слід навести протилежність, а саме StateFullWidget(зі станом).
Для цього я використав приклад списку котрий відображає додаток (див. \ref{lst:flutter_app_widget}).

Головне, що треба розуміти в випадку віджетів зі станом це те, що зміна стану приводить до перемалювання віджету.
Оскільки один віджет може повертати довільно складне дерево віджетів, то зміна стану головної ланки призведе до зміни віджетів під\'єрархії.

\subsection{Система побудування з використанням Flutter CLI}
\label{subsec:flutter_cli_theory}
Flutter CLI - інструмент командного рядка котрий дозволяє створити, виконати, зібрати сирцевий код проектів фреймфорку Flutter.

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_cli_create},caption=Flutter Create Project]
flutter create my_app
cd my_app
flutter analyze
flutter test
flutter run lib/main.dart
\end{lstlisting}

В лістингу \ref{lst:flutter_cli_create} наведена команда, що створює, перевіряє, запускає тести та відтворює код додатку.

В лістингу \ref{lst:flutter_pub} наведен приклад набору інсрументів,
що завантажує, конфігурує та під'єднує транзитивні залежності до проекту.

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_pub},caption=Flutter Dependency Resolution]
flutter pub get
flutter pub outdated
flutter pub upgrade
\end{lstlisting}

Повний список залежностей можна знайти на офіційній веб сторінці \cite{flutter_cli}.

\subsection{Flutter та пакет http.dart}
\label{subsec:flutter_http_dart_theory}
Отримання даних з Інтернету необхідно для більшості програм.
Для цього виду робіт Dart і Flutter надають інструменти, такі як httpпакет.

Цей пакет містить набір функцій та класів високого рівня, що полегшують споживання ресурсів HTTP.
http.dart підтримує мобільну, настільну та браузерні платформи.

Використання функцій верхнього рівня дозволяє робити окремі HTTP-запити.
Якщо є потреба робити кілька запитів на один і той же сервер, тоді зручніше всього тримати відкритим постійне з’єднання,
використовуючи клієнт, а не одноразові запити.

\begin{lstlisting}[style=light, language=Python,label={lst:flutter_pub},caption=Flutter Dependency Resolution]
import 'package:http/http.dart' as http;
var client = http.Client();
try {
  var uriResponse = await client.post(Uri.parse('https://example.com/whatsit/create'),
      body: {'name': 'doodle', 'color': 'blue'});
  print(await client.get(uriResponse.bodyFields['uri']));
} finally {
  client.close();
}
\end{lstlisting}

В нашому додатку запит до інтернету описан в наступному описі сирцевого коду \ref{lst:flutter_networking}.

Головним принципом, котрим я керуюся в прикладі з запитои до інтернету, це використання "обіцянок" на базі dart:async Future<T>.
Асинхронні операції дозволяють нашій програмі завершити роботу не чекаючи закінчення іншої операції.
Результат використання Future API або закінчиться в завершенному стані або незавершенному.
Future API за принципом схожий на Javascrip Promise API.

Перше виконанє асинхронної функції повертає посилання на незавершену дію, з якої можна отримати або результат, або помилку.
Щоб уникнути розповсюдження помилки в стеку викликів треба використати try/catch синтаксис.

Як видно з прикладу (див. \ref{lst:flutter_networking}), використання пакету http.dart в по'єднанні з dart:async дає зручне
та швидке розв'язання проблеми створення та прослухання результатів з інтернету.

\subsection{Flutter та пакет sqflite}
\label{subsec:flutter_sqflite_theory}
SQFlite - це порт SQLite драйверу для платформ iOS, Android та MacOS написаний на мові Dart.

До можливостей sqflite можна віднести:

\begin{itemize}
    \item Підтримка транзакцій та пакетів.
    \item Помічники для вставки / запиту / оновлення / видалення запитів.
    \item Операції до БД, виконуються у фоновому потоці на iOS та Android.
    \item Підтримка Linux / Windows / DartVM за допомогою sqflite_common_ffi.
\end{itemize}

Рішення, що використовує цю бібліотеку можна знайти за наступним посиланням \ref{lst:flutter_sqflite}.

SQFlite було огорнуто в додатковий тип \textbf{BreedDatabase},
що дає перевагу в майбутньому без великих втрат замінити SQFLite іншим рішенням для комунікації з БД.
\textbf{BreedDatabase} дає можливість виконання стандартних процедур підключення до БД з розширенням .sqlite
на стандартному шляху до файлу абстрагованого за допомогою \textbf{getDatabasesPath()} API.

Оскільки наша огортка, це вікно в SQL світ, то наш додаток здатен виконувати всі доступні із стандартного набору
SQL операції.

\subsection{Управління станом в Flutter}
\label{subsec:flutter_state_app}
Flutter пропонує кілька способів для управління станом. Серед них BLoC, Provider, Statefull Widgets, InheritedWidgets.
В даній роботі я розгляну Provider API, яка взяла за основу систему InheritedWidgets(віджет, що наслідує).
Для того щоби зрозуміти контроль стану з Provider API треба розглянути наступні класи:

\begin{itemize}
    \begin{item}
        ChangeNotifier - це простий клас, включений до Flutter SDK,
        який забезпечує повідомлення про зміни своїх слухачів.
        Іншими словами, якщо щось є ChangeNotifier, ви можете підписатися на його зміни.
    \end{item}
    \begin{item}
        ChangeNotifierProvider - це віджет, який надає екземпляр ChangeNotifier своїм нащадкам.
        Це походить від пакету провайдера.
    \end{item}
    \begin{item}
        Consumer - це віджет, що дозволяє нам огорнути будь-який інший віджит далі
        в ієрархії та зчитати стан з класу, що наслідує ChangeNotifier.
    \end{item}
\end{itemize}

В додатку я використав StateNotifier, котрий обновлює всіх підписників стану.
Так наприклад зміна значення з стану "завантажується" на стан "завантажений"
приводить до перебудови віджету \ref{lst:flutter_sqflite}.

\subsection{Юніт тестування в Flutter}
\label{sec:flutter_unit_testing_app}
Як було вже зазначено, найкращий спосіб контролю якості в проекті - це написання та супроводження коду написанням юніт тестів.
Цей підхід до розробки програмного забезпечення не оминув і розробку під Flutter.

В даній секції я навожу приклад тесту написаного для коду бізнес логіки \ref{lst:flutter_unit_test}.
Я застосував пакети test та mockito.
Пакет тест надає доступ до функцій, які дозволяють згрупувати тести.
Пакет mockito надає функціонал, що дозволяє конфігурувати поведінку об'єктів типу mock(об'єкт макет).

В проекті я працюю з двома "рухомими" залежностями: шар комунікації з мережею та БД.
Рухома частина - це те що ми, як користувачі бібліотек http.dart та SQFlite не контролюємо.
Отже, щоб спростити конфігурацію юніт тестування я замінив реальні об'єкти на об'єкти макети.


\section{Фреймворк Kotlin Multiplatform (KMM)}
\label{sec:kmm}

\subsection{UI та Kotlin Multiplatform}
\label{subsec:kmm_ui}
Специфіка розробки з використанням Kotlin Multiplatform передбачує, що розробка рівня UI буде досягнута
інструментами нативними для платформи.

Для розробки UI під Android використовується декларативний XML, що відтворюється під час виконання в середовищі компоненту
контейнера так званої Activity(активність) (див. \ref{lst:android_xml}).

Нещодавно з'явився тренд розробки UI з уживанням
Kotlin DSL(Domain Specific Language - Специфічна Мова Домену) так званий Jetpack Compose \cite{jetpack_compose}.

Як видно з лістингу \ref{lst:android_jetpack_compose} Android екосистема взяла той самий напрямок, що Flutter та React Native.
Такий самий тренд можна спостерігати і в розробці під iOS, де декларативний синтаксис описується з Swift UI \cite{swift_ui}.

В лістингах \ref{lst:android_jetpack_compose} та \ref{lst:ios_swift_ui} для Android та iOS наведені приклади декларативної розробки UI.
Стає зрозуміло, що Kotlin Multiplatform не розв'язує проблему спільної бази коду для рівня рендерінгу.
Це дуже важливий момент, оскільки весь UI треба дуплікувати під кожну платформу.
Задачу яку розв\'язує Kotlin Multiplatform, це опис спільної логіки, тобто звернення до бази даних, файлової системи, інернету, тощо.

\subsection{Система побудування Gradle та Kotlin Multiplatform}
\label{subsec:kmm_gradle}

Kotlin Multiplatform використовує Gradle як систему побудування проектів розроблена зокрема для проектів під JVM платформу.
Gradle - це інструмент автоматизації збірки з відкритим кодом, орієнтований на гнучкість та продуктивність. \cite{gradle_user_manual}
Сценарії збірки Gradle пишуться із використанням DSL Groovy або Kotlin. \cite{gradle_user_manual}

Оскільки Kotlin спочатку був розроблен для JVM систем, то був на раніх етапах інтегрован в екосистему.
З розвитком Kotlin Multiplatform дана система була наслідувана і надалі використовується для побудування крос-платформеного проекту.

Модуль зі спільним кодом є бібліотекою для Android, він також містить власний build.gradle сценарій, де описані залежності.
Cценарій "shared/build.gradle.kts", описує конфігурації сирцевих кодів з використанням sourceSets, що відповідає каталогам у спільному проекті.

Кожна частина бібліотеки, оголошує власні залежності в визначених наборах джерел.
Наприклад, бібліотека параметрів мультиплатформних налаштувань оголошується лише у commonMain та commonTest,
оскільки бібліотека використовує метадані gradle для виведення залежних від конкретних платформ залежностей.
Інші бібліотеки, які залежать від реалізації платформи, наприклад SqlDelight, вимагають конфігурації яка задовольнить
умовам середи виконання.

Наприклад для sourceSet commonMain визначена залежність з пакету sqlDelight.runtime, а в androidMain sqlDelight.driverAndroid.

\subsection{Комунікація з мережею в KMM http.dart з ktor та couroutines}
\label{subsec:kmm_ktor}
На даний момент серед кроссплатформених бібліотек, що дозволяє нам моделювання інтернет викликів,
найпоширенішою - є розв'язання Ktor \cite{ktor_home_page}.
В додатку коду, що наведений нижче \ref{lst:kmm_ktor} я навожу приклад реалізації клієнта,
що створює з'єднання з API сервісом та повертає нам список порід собак.

Важливим моментом є те, що функція визначена ключовим словом \textbf{suspend}.
\textbf{suspend} маркерує нашу функцію, як ту, що буде виконувати "блокуючу" операцію.

Реалізація виклику за допомогою Ktor та Kotlin в лістинну \ref{lst:kmm_ktor} хоч і виглядає громоздко, але не є складною.
Більшість логіки, що створює сокет і опрацьовує потік байтів, схована за публічним інтерфейсом.
Від клієнта потребується декларування викликів та дизайн DTO(Data Transfer Object - Транспортний Об'єкт Даних),
в нащому випадку це клас, що описує структуру Json відповіді BreedResult.

\subsection{Комунікація з БД в KMM з SQLDelight}
\label{subsec:kmm_sqldelight}
Для роботи з БД в KMM(Kotlin) проекті було використано бібліотеку SQLDelight \cite{sqldelight_home}.
SQLDelight генерує код для клієнту на основі SQL визначень описаних в окремому файлі.

Як видно в лістингу \ref{lst:table_sq_gen} спочатку я описав структуру таблиць за допомогою SQL.
Далі створив інструкцію \textbf{selectAll}, що буде використана SQLDelight для генерації коду лістингу \ref{lst:table_sq_gen}.

Результатом виконання SQL запиту буде посилання на об'єкт типу курсор, що дозволяє в динамічний спосіб зчитати
результат та адоптувати результат до конкретного типу. Таким чином, я уникнув написання низькорівневого коду,
в якому дуже просто припуститися помилки. В випадку більш складних схем БД перевага згенерованого коду дозволяє
нам уникати надмірного повторення в написанні коду прослойки для коммунікації з БД.

\subsection{Юніт тестування в KMM додатку}
\label{subsec:kmm_unit_testing}

Як і в випадку інших платформ розробки тестування коду є критичною для розвитку продукту.
KMM і тут не відстає і пропонує розв'язання для тестування.
Оскільк Kotlin підтримує JVM(Java Virtual Machine) середовище тести можна запустити під Linux, Windows та MacOS платформами.

Тести, що супроводжують загальну логіку тримають в відокремленому репозиторії commonTest.
Для конфігурації специфічного для платформи коду виділяють iosTest для iOS та androidTest для Android платформ.

В нашому додатку був написаний простий інтеграційний тест (див. \ref{lst:kotin_test_common}).
Дуже важливо підкреслити наявність ф-цій \textbf{testDbConnection} та \textbf{runTest}.
Де \textbf{testDbConnection} абстрагує реалізацію драйверу підключення до БД та буде реалізована для кожної
з платформ в своєму специфічному вихідному наборі (ios, android).
\textbf{runTest} абстрагує реалізацію логіки запуску тесту.
Модель багатопотоковість унікальна для кожної з платформ, тому впроваджується абстракція та конкретна реалізація
для кожної з платформ.

Важливо зауважити, що моє рішення засноване на базі \textbf{expect} та \textbf{actual} парі.
Дані ключові слова маркерують ф-ції, як ті що залежать від API специфічного для платформи.
Даний функціонал специфічний для Kotlin Mulitplatform.

В лістингу \ref{lst:kotin_test_ios} я використовую в якості реалізації драйвер специфічний для iOS платформи.

В лістингу \ref{lst:kotin_test_android} я використовую в якості реалізації драйвер специфічний для Android платформи.

З наведених приклавдів можно зробити висновок, що KMM намагається максимально тісно співпрацювати з API специфічний для платформ.
Таке рішення потребує знання не тільки специфіки Kotlin, але й розуміння бібліотек специфічних для платформ.
Тобто KMM не будує додатковий рівень абстракції, що ховає доступ до конкретних специфікацій замість цього надає
Kotlin API, що відзеркалює API нативних для платформи бібліотек.
